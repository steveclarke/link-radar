# frozen_string_literal: true

require "rails/generators"
require "rails/generators/named_base"
require "rails/generators/active_record"

module LinkRadar
  module Generators
    class StateMachineGenerator < Rails::Generators::NamedBase
      include ActiveRecord::Generators::Migration

      desc "Generate a complete Statesman-based state machine with LinkRadar conventions"

      source_root File.expand_path("templates", __dir__)

      # Arguments
      argument :states, type: :array, default: [], banner: "state1 state2:initial state3"

      # Required by ActiveRecord::Generators::Migration
      def self.next_migration_number(dirname)
        Time.now.utc.strftime("%Y%m%d%H%M%S")
      end

      def initialize(args, *options)
        super
        @model_name = name.camelize
        @snake_name = name.underscore
        @transition_model_name = "#{@model_name}Transition"
        @transition_snake_name = "#{@snake_name}_transition"
        @state_machine_name = "#{@model_name}StateMachine"
        @parsed_states = parse_states
      end

      # Main generator action
      def generate_state_machine
        validate_prerequisites
        say "Creating LinkRadar state machine for #{@model_name}..."

        create_state_machine_class
        create_transition_model
        create_transitions_migration
        create_transition_factory
        create_transition_model_spec
        create_state_machine_spec
        integrate_parent_model

        say "âœ… State machine created successfully!", :green
        say_usage_instructions
      end

      def create_state_machine_class
        say "  ðŸ“„ Creating state machine class...", :blue
        template "state_machine.rb.tt", "app/state_machines/#{@snake_name}_state_machine.rb"
      end

      def create_transition_model
        say "  ðŸ“„ Creating transition model...", :blue
        template "transition_model.rb.tt", "app/models/#{@transition_snake_name}.rb"
      end

      def create_transitions_migration
        say "  ðŸ“„ Creating migration...", :blue
        migration_template "migration.rb.tt", "db/migrate/create_#{@transition_snake_name.pluralize}.rb"
      end

      def create_transition_factory
        say "  ðŸ“„ Creating transition factory...", :blue
        template "transition_factory.rb.tt", "spec/factories/#{@transition_snake_name.pluralize}.rb"
      end

      def create_transition_model_spec
        say "  ðŸ“„ Creating transition model spec...", :blue
        template "transition_model_spec.rb.tt", "spec/models/#{@transition_snake_name}_spec.rb"
      end

      def create_state_machine_spec
        say "  ðŸ“„ Creating state machine spec...", :blue
        template "state_machine_spec.rb.tt", "spec/models/#{@snake_name}_state_machine_spec.rb"
      end

      def integrate_parent_model
        say "  ðŸ“„ Integrating with parent model...", :blue

        model_path = "app/models/#{@snake_name}.rb"

        # Add the full Statesman integration block
        inject_into_class model_path, @model_name do
          <<~RUBY

            # =============================================================================
            # Statesman State Machine Integration
            # =============================================================================
            # This section was generated by: rails generate link_radar:state_machine #{@model_name}
            #
            # State machine: #{@state_machine_name}
            # Transition model: #{@transition_model_name}
            #
            # Documentation:
            #   - Statesman gem: https://github.com/gocardless/statesman
            #   - LinkRadar guide: project/guides/backend/state-machines-guide.md
            #
            # Usage:
            #   #{@snake_name}.state_machine.current_state
            #   #{@snake_name}.state_machine.transition_to!(:new_state)
            #   #{@model_name}.in_state(:some_state)
            # =============================================================================

            # Association to transition records
            has_many :#{@transition_snake_name.pluralize}, autosave: false

            # Statesman query scopes and integration
            include Statesman::Adapters::ActiveRecordQueries[
              transition_class: #{@transition_model_name},
              initial_state: :#{initial_state}
            ]

            # State machine instance
            def state_machine
              @state_machine ||= #{@state_machine_name}.new(
                self,
                transition_class: #{@transition_model_name},
                association_name: :#{@transition_snake_name.pluralize}
              )
            end

            # Convenience delegate methods for easier access
            delegate :current_state, :can_transition_to?, :transition_to!,
                     :allowed_transitions, to: :state_machine

            # =============================================================================
            # End Statesman State Machine Integration
            # =============================================================================

          RUBY
        end
      end

      private

      def parse_states
        if states.empty?
          # Default states: draft:initial, active
          parsed = [
            {name: "draft", initial: true},
            {name: "active", initial: false}
          ]
        else
          parsed = []
          initial_count = 0

          states.each_with_index do |state_arg, index|
            if state_arg.include?(":")
              state_name, flag = state_arg.split(":", 2)
              if flag == "initial"
                parsed << {name: state_name, initial: true}
                initial_count += 1
              else
                raise Thor::Error, "Unknown state flag '#{flag}'. Only 'initial' is supported."
              end
            else
              # No flag - initial if it's first and no explicit initial set yet
              is_initial = index == 0 && initial_count == 0
              parsed << {name: state_arg, initial: is_initial}
              initial_count += 1 if is_initial
            end
          end

          if initial_count == 0
            # Make first state initial if none specified
            parsed.first[:initial] = true if parsed.any?
          elsif initial_count > 1
            raise Thor::Error, "Only one state can be marked as :initial"
          end
        end

        # Calculate simple transitions: linear progression + ability to jump to final state
        parsed.each_with_index do |state, index|
          transitions = []

          # Can transition to next state (linear progression)
          if index < parsed.length - 1
            transitions << parsed[index + 1][:name]
          end

          # Can transition to final state from any non-final state (e.g., cancel)
          if index < parsed.length - 1 && parsed.length > 2
            final_state = parsed.last[:name]
            transitions << final_state unless transitions.include?(final_state)
          end

          state[:transitions_to] = transitions
        end

        parsed
      end

      def validate_prerequisites
        # Check if Statesman is configured
        unless File.exist?("config/initializers/statesman.rb")
          raise Thor::Error, "Statesman initializer not found. Create config/initializers/statesman.rb first."
        end

        # Check if target model exists
        model_path = "app/models/#{@snake_name}.rb"
        unless File.exist?(model_path)
          raise Thor::Error, "Target model #{@model_name} not found at #{model_path}. " \
                            "This generator only adds state machine functionality to existing models. " \
                            "Create the #{@model_name} model first, then run this generator."
        end

        # Check if transition model already exists
        transition_path = "app/models/#{@transition_snake_name}.rb"
        if File.exist?(transition_path)
          raise Thor::Error, "Transition model #{@transition_model_name} already exists at #{transition_path}"
        end
      end

      def say_usage_instructions
        say "\nðŸ“‹ Next steps:", :blue
        say "1. Run: rails db:migrate"
        say "2. Test in console:"
        say "   #{@snake_name} = #{@model_name}.first"
        say "   #{@snake_name}.state_machine.current_state"
        say "   #{@snake_name}.state_machine.transition_to!(:#{@parsed_states.last[:name]})"
      end

      def initial_state
        @parsed_states.find { |s| s[:initial] }&.dig(:name) || "draft"
      end

      def state_names
        @parsed_states.pluck(:name)
      end
    end
  end
end
