#!/usr/bin/env bash
set -euo pipefail

################################################################################
# Link Radar Deployment Script
################################################################################
#
# OVERVIEW
# --------
# Automated deployment of Link Radar to remote servers via SSH. Supports
# multiple environments (prod, staging, test, etc.) with state tracking for
# truly idempotent deploys.
#
# MODES
# -----
# Install Mode (DEPLOYED=false):
#   - Full deployment setup
#   - Generates environment files
#   - Starts services
#   - Marks as deployed
#
# Update Mode (DEPLOYED=true):
#   - Pulls latest code and images
#   - Restarts services
#   - Preserves existing configuration
#
# CONFIGURATION
# -------------
# Environment config file: .config/{ENVIRONMENT}.env
#
# Required fields:
#   DEPLOY_HOST           Server hostname or IP
#   ONEPASSWORD_ITEM_ID   1Password item ID for credentials
#   DEPLOYED              false (first deploy) or true (updates)
#
# CREDENTIALS
# -----------
# Auto-sourced from 1Password (primary method):
#   - username (defaults to "deploy")
#   - Database Password (only for first deploy)
#   - API Key (preserved across updates)
#   - Rails Master Key (from local backend/config/master.key)
#
# USAGE
# -----
#   bin/deploy prod              Deploy to production
#   bin/deploy staging           Deploy to staging
#   bin/deploy test --check      Check prerequisites only
#
################################################################################

# Colors for output
red='\033[0;31m'
green='\033[0;32m'
yellow='\033[1;33m'
blue='\033[0;34m'
nc='\033[0m'

################################################################################
# Main Orchestration
################################################################################

main() {
  parse_arguments "$@"

  # Handle initialization mode
  if [ "$init_mode" = true ]; then
    init_environment
    exit 0
  fi

  load_environment_config
  load_credentials
  check_prerequisites

  if [ "$deployed" == "true" ]; then
    info "Update mode: pulling latest and restarting"
    update_deployment
  else
    info "Install mode: full deployment"
    install_deployment
    mark_as_deployed
  fi

  verify_deployment

  echo ""
  log "ðŸŽ‰ Deployment complete!"
  echo ""
  echo "Your Link Radar backend is running on ${deploy_host}"
  echo ""
  echo "Next steps:"
  echo "  - View logs: ssh ${deploy_user}@${deploy_host} 'cd ~/docker/link-radar/deploy && ./bin/logs'"
  echo "  - Check status: ssh ${deploy_user}@${deploy_host} 'cd ~/docker/link-radar/deploy && docker compose ps'"
  echo "  - Rails console: ssh ${deploy_user}@${deploy_host} 'cd ~/docker/link-radar/deploy && ./bin/console'"
  if [ "$deployed" != "true" ]; then
    echo ""
    warn "Save credentials to 1Password if not already saved!"
  fi
  echo ""
}

################################################################################
# Helper Functions
################################################################################

log() { echo -e "${green}==>${nc} ${1}"; }
info() { echo -e "${blue}Info:${nc} ${1}"; }
warn() { echo -e "${yellow}Warning:${nc} ${1}"; }
error() { echo -e "${red}Error:${nc} ${1}" >&2; exit 1; }

################################################################################
# 1Password Helper Functions
################################################################################

# Check if 1Password CLI is available
has_onepassword_cli() {
  command -v op &> /dev/null
}

# Check if 1Password is available and configured
can_use_onepassword() {
  [ -n "${onepassword_item_id:-}" ] && has_onepassword_cli
}

# Get a field from 1Password, returns empty string if unavailable
# Usage: get_onepassword_field "label_name" [--reveal]
get_onepassword_field() {
  local label="$1"
  local reveal_flag="${2:-}"

  if ! can_use_onepassword; then
    echo ""
    return 1
  fi

  local value
  if [ "$reveal_flag" == "--reveal" ]; then
    value=$(op item get "$onepassword_item_id" --fields "label=${label}" --reveal 2>/dev/null || echo "")
  else
    value=$(op item get "$onepassword_item_id" --fields "label=${label}" 2>/dev/null || echo "")
  fi

  echo "$value"
  [ -n "$value" ]
}

################################################################################
# Supporting Functions
################################################################################

usage() {
  cat << EOF
Usage: bin/deploy ENVIRONMENT [OPTIONS]

Automated deployment of Link Radar to a remote server.

Arguments:
  ENVIRONMENT         Environment name (required: prod, staging, test, etc.)
                      Loads .config/ENVIRONMENT.env

Configuration File (.config/ENV.env):
  DEPLOY_HOST           Server hostname or IP
  ONEPASSWORD_ITEM_ID   1Password item ID containing credentials
  DEPLOYED              State tracking (false=install, true=update)

Options:
  -h, --help          Show this help message
  -c, --check         Check prerequisites only, don't deploy

Initialization Options:
  --init              Initialize environment configuration (creates .config/ENV.env)
  --host HOST         Specify DEPLOY_HOST (required for non-interactive init)
  --op ITEM_ID        Specify 1Password item ID (required for non-interactive init)
  --deployed          Mark server as already deployed (use for existing deployments)
  --user USERNAME     Override DEPLOY_USER (default: deploy)
  --image IMAGE       Override BACKEND_IMAGE (default: ghcr.io/steveclarke/lr-backend:latest)
  --port PORT         Override BACKEND_PORT (default: 3000)
  --force             Overwrite existing config without prompting

Deployment Examples:
  bin/deploy prod               # Deploy to production
  bin/deploy staging            # Deploy to staging
  bin/deploy test --check       # Check prerequisites only

Initialization Examples:
  # Interactive mode - prompts for missing values
  bin/deploy prod --init --deployed

  # Non-interactive mode - all values provided
  bin/deploy prod --init --host=server.example.com --op=abc123xyz --deployed

  # Fresh install configuration
  bin/deploy staging --init --host=staging.example.com --op=def456

  # Override defaults
  bin/deploy prod --init --host=server.com --op=abc123 --user=ubuntu --port=8080

  # Force overwrite existing config
  bin/deploy prod --init --host=server.com --op=abc123 --force

Typical Workflow:
  1. Initialize environment:     bin/deploy prod --init --deployed
  2. Verify configuration:       bin/deploy prod --check
  3. Deploy:                     bin/deploy prod

EOF
  exit 0
}

################################################################################
# Initialization Functions
################################################################################

init_environment() {
  local template_file
  local config_file
  template_file="$(dirname "$0")/../.config/environment.env.template"
  config_file="$(dirname "$0")/../.config/${deploy_env}.env"

  log "Initializing environment: ${deploy_env}"

  # Check if template exists
  if [ ! -f "$template_file" ]; then
    error "Template not found: .config/environment.env.template"
  fi

  # Check if config already exists
  if [ -f "$config_file" ] && [ "$init_force" != true ]; then
    warn "Config already exists: .config/${deploy_env}.env"
    if [ -t 0 ]; then
      read -p "Overwrite existing config? (y/n): " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "Cancelled. Use --force to overwrite without prompting."
        exit 0
      fi
    else
      error "Config exists. Use --force to overwrite."
    fi
  fi

  # Interactive prompts for missing required values
  if [ -t 0 ]; then
    # Prompt for DEPLOY_HOST if not provided
    if [ -z "$init_host" ]; then
      read -r -p "Server hostname or IP: " init_host
      if [ -z "$init_host" ]; then
        error "DEPLOY_HOST is required"
      fi
    fi

    # Prompt for ONEPASSWORD_ITEM_ID if not provided
    if [ -z "$init_op" ]; then
      read -r -p "1Password item ID: " init_op
      if [ -z "$init_op" ]; then
        error "ONEPASSWORD_ITEM_ID is required"
      fi
    fi

    # Prompt for deployed status if not set
    if [ "$init_deployed" != true ]; then
      read -p "Is the server already deployed? (y/n): " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        init_deployed=true
      fi
    fi
  else
    # Non-interactive: validate required arguments
    if [ -z "$init_host" ]; then
      error "Non-interactive mode: --host is required"
    fi
    if [ -z "$init_op" ]; then
      error "Non-interactive mode: --op is required"
    fi
  fi

  # Set deployed flag
  local deployed_value="false"
  if [ "$init_deployed" = true ]; then
    deployed_value="true"
  fi

  # Create config from template
  log "Creating config file..."
  cp "$template_file" "$config_file"

  # Substitute values in config file
  sed -i.bak "s|^DEPLOY_HOST=.*|DEPLOY_HOST=${init_host}|" "$config_file"
  sed -i.bak "s|^ONEPASSWORD_ITEM_ID=.*|ONEPASSWORD_ITEM_ID=${init_op}|" "$config_file"
  sed -i.bak "s|^DEPLOYED=.*|DEPLOYED=${deployed_value}|" "$config_file"

  # Handle optional overrides
  if [ -n "$init_user" ]; then
    sed -i.bak "s|^#DEPLOY_USER=.*|DEPLOY_USER=${init_user}|" "$config_file"
  fi
  if [ -n "$init_image" ]; then
    sed -i.bak "s|^#BACKEND_IMAGE=.*|BACKEND_IMAGE=${init_image}|" "$config_file"
  fi
  if [ -n "$init_port" ]; then
    sed -i.bak "s|^#BACKEND_PORT=.*|BACKEND_PORT=${init_port}|" "$config_file"
  fi

  # Clean up backup file
  rm -f "${config_file}.bak"

  log "Config created: .config/${deploy_env}.env"
  info "Mode: $([ "$deployed_value" == "true" ] && echo "UPDATE (server already deployed)" || echo "INSTALL (fresh deployment)")"

  # Verify setup
  echo ""
  log "Verifying configuration..."

  # Source the new config and run prerequisite checks
  load_environment_config
  load_credentials
  check_prerequisites

  echo ""
  log "âœ“ Environment initialized successfully!"
  echo ""
  echo "Next steps:"
  if [ "$deployed_value" == "true" ]; then
    echo "  - Deploy updates: bin/deploy ${deploy_env}"
  else
    echo "  - Deploy for first time: bin/deploy ${deploy_env}"
  fi
  echo ""
}

################################################################################
# Configuration Functions
################################################################################

parse_arguments() {
  # Parse environment argument (required)
  if [ "${1:-}" == "-h" ] || [ "${1:-}" == "--help" ] || [ -z "${1:-}" ]; then
    usage
  fi

  deploy_env="$1"
  shift

  # Parse remaining arguments
  check_only=false
  init_mode=false
  init_force=false
  init_host=""
  init_op=""
  init_deployed=false
  init_user=""
  init_image=""
  init_port=""

  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help) usage ;;
      -c|--check) check_only=true; shift ;;
      --init) init_mode=true; shift ;;
      --force) init_force=true; shift ;;
      --host) init_host="$2"; shift 2 ;;
      --op) init_op="$2"; shift 2 ;;
      --deployed) init_deployed=true; shift ;;
      --user) init_user="$2"; shift 2 ;;
      --image) init_image="$2"; shift 2 ;;
      --port) init_port="$2"; shift 2 ;;
      *) error "Unknown option: $1" ;;
    esac
  done
}

load_environment_config() {
  config_file="$(dirname "$0")/../.config/${deploy_env}.env"

  if [ ! -f "$config_file" ]; then
    error "Config not found: .config/${deploy_env}.env

Create from template:
  cp .config/environment.env.template .config/${deploy_env}.env"
  fi

  # shellcheck source=/dev/null
  source "$config_file"
  info "Environment: ${deploy_env}"

  # Map config file variables (UPPERCASE) to local variables (snake_case)
  # shellcheck disable=SC2153
  deploy_host="${DEPLOY_HOST}"
  onepassword_item_id="${ONEPASSWORD_ITEM_ID:-}"
  deployed="${DEPLOYED:-false}"
  deploy_user="${DEPLOY_USER:-deploy}"
  backend_image="${BACKEND_IMAGE:-ghcr.io/steveclarke/lr-backend:latest}"
  backend_port="${BACKEND_PORT:-3000}"
}

load_credentials() {
  # Warn if 1Password CLI is not available but config expects it
  if [ -n "${onepassword_item_id:-}" ] && ! has_onepassword_cli; then
    warn "1Password CLI not found - install it or set credentials via environment variables"
    warn "Install: https://developer.1password.com/docs/cli/get-started/"
  fi

  # Auto-fetch credentials from 1Password
  if can_use_onepassword; then
    if op item get "$onepassword_item_id" &> /dev/null 2>&1; then
      info "Loading credentials from 1Password..."

      local op_user op_password
      op_user=$(get_onepassword_field "username")
      op_password=$(get_onepassword_field "Database Password" --reveal)

      deploy_user="${deploy_user:-${op_user:-deploy}}"
      RAILS_MASTER_KEY="${RAILS_MASTER_KEY:-$(cat "$(dirname "$0")/../../backend/config/master.key" 2>/dev/null || echo "")}"
      db_password="${db_password:-${op_password}}"

      log "Credentials loaded from 1Password"
    fi
  fi
}

################################################################################
# Validation Functions
################################################################################

check_prerequisites() {
  log "Checking prerequisites..."

  # Required variables
  [[ -z "${deploy_host:-}" ]] && error "deploy_host not set"
  [[ -z "${RAILS_MASTER_KEY:-}" ]] && error "RAILS_MASTER_KEY not set"

  info "Deploy host: ${deploy_host}"
  info "Deploy user: ${deploy_user}"
  info "Backend image: ${backend_image}"
  info "Mode: $([ "$deployed" == "true" ] && echo "UPDATE" || echo "INSTALL")"

  test_ssh_connection
  check_database_password_requirement

  if [ "$check_only" = true ]; then
    log "Prerequisites check passed!"
    exit 0
  fi
}

test_ssh_connection() {
  log "Testing SSH connection..."
  if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "${deploy_user}@${deploy_host}" "echo 'SSH OK'" &>/dev/null; then
    error "Cannot connect to ${deploy_user}@${deploy_host}. Check SSH access."
  fi
  log "SSH connection successful"
}

check_database_password_requirement() {
  # Only check if in install mode
  if [ "$deployed" != "true" ]; then
    if ssh "${deploy_user}@${deploy_host}" "docker volume ls 2>/dev/null | grep -q postgres_data" 2>/dev/null; then
      info "PostgreSQL volume exists, skipping db_password requirement"
    else
      info "First deploy detected, db_password required"
      if [ -z "${db_password:-}" ]; then
        db_password=$(openssl rand -base64 32)
        warn "Generated new db_password - save to 1Password!"
        echo ""
        echo "  Database Password: $db_password"
        echo ""
        warn "Add this to your 1Password item: $onepassword_item_id"
      fi
    fi
  fi
}

################################################################################
# Install Mode Functions
################################################################################

install_deployment() {
  log "Starting full installation to ${deploy_host}..."
  echo ""

  setup_deploy_directory
  run_setup_script
  generate_env_files
  pull_images
  start_services
}

setup_deploy_directory() {
  log "Setting up deploy directory on server..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
set -e
mkdir -p ~/docker
cd ~/docker

# Clone if not exists, otherwise update
if [ ! -d "link-radar" ]; then
  echo "Cloning repository..."
  git clone --filter=blob:none --sparse https://github.com/steveclarke/link-radar.git
  cd link-radar
  git sparse-checkout set --no-cone deploy/
else
  echo "Updating existing repository..."
  cd link-radar
  git fetch origin
  git reset --hard origin/master
fi

cd deploy
echo "Deploy directory ready: $(pwd)"
ENDSSH

  log "Deploy directory ready"
}

run_setup_script() {
  log "Running setup script..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
cd ~/docker/link-radar/deploy
./bin/setup
ENDSSH

  log "Setup complete"
}

generate_env_files() {
  log "Generating environment files from templates..."

  # Get API key (1Password â†’ existing â†’ generate)
  get_api_key

  # Get S3 credentials for backups (optional)
  get_s3_credentials

  # URL-encode the password for use in DATABASE_URL
  db_password_encoded=$(printf '%s' "${db_password}" | jq -sRr @uri)

  # Build complete DATABASE_URL
  database_url="postgresql://linkradar:${db_password_encoded}@postgres:5432/linkradar_production"

  # Generate .env from template
  info "Generating .env..."
  cat "$(dirname "$0")/../env.template" | \
    sed 's|^BACKEND_IMAGE=.*|BACKEND_IMAGE='"${backend_image}"'|' | \
    sed 's|^BACKEND_PORT=.*|BACKEND_PORT='"${backend_port}"'|' | \
    ssh "${deploy_user}@${deploy_host}" "cat > ~/docker/link-radar/deploy/.env"

  # Generate env/backend.env from template
  info "Generating env/backend.env..."
  cat "$(dirname "$0")/../env/backend.env.template" | \
    sed 's|^RAILS_MASTER_KEY=.*|RAILS_MASTER_KEY='"${RAILS_MASTER_KEY}"'|' | \
    sed 's|^DATABASE_URL=.*|DATABASE_URL='"${database_url}"'|' | \
    sed 's|^CORE_API_KEY=.*|CORE_API_KEY='"${api_key}"'|' | \
    ssh "${deploy_user}@${deploy_host}" "cat > ~/docker/link-radar/deploy/env/backend.env"

  # Generate env/postgres.env from template
  info "Generating env/postgres.env..."
  cat "$(dirname "$0")/../env/postgres.env.template" | \
    sed 's|^POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD='"${db_password}"'|' | \
    ssh "${deploy_user}@${deploy_host}" "cat > ~/docker/link-radar/deploy/env/postgres.env"

  # Generate env/backup.env from template (if S3 credentials available)
  if [ -n "${s3_access_key:-}" ]; then
    info "Generating env/backup.env..."
    cat "$(dirname "$0")/../env/backup.env.template" | \
      sed 's|^ACCESS_KEY_ID=.*|ACCESS_KEY_ID='"${s3_access_key}"'|' | \
      sed 's|^SECRET_ACCESS_KEY=.*|SECRET_ACCESS_KEY='"${s3_secret_key}"'|' | \
      sed 's|^BUCKET=.*|BUCKET='"${s3_bucket}"'|' | \
      sed 's|^HOST_BASE=.*|HOST_BASE='"${s3_endpoint}"'|' | \
      sed 's|^HOST_BUCKET=.*|HOST_BUCKET=%(bucket)s.'"${s3_endpoint}"'|' | \
      ssh "${deploy_user}@${deploy_host}" "cat > ~/docker/link-radar/deploy/env/backup.env"
  else
    info "Skipping env/backup.env (S3 credentials not available)"
  fi

  log "Environment files generated from templates"
}

get_api_key() {
  # Try 1Password first
  if can_use_onepassword; then
    api_key=$(get_onepassword_field "API Key" --reveal)
    if [ -n "$api_key" ]; then
      info "API key loaded from 1Password"
      return
    fi
  fi

  # Try to preserve existing from server
  api_key=$(ssh "${deploy_user}@${deploy_host}" "grep CORE_API_KEY ~/docker/link-radar/deploy/env/backend.env 2>/dev/null | cut -d= -f2" || echo "")
  if [ -n "$api_key" ]; then
    info "Preserved existing API key from server"
    return
  fi

  # Generate new one
  api_key=$(openssl rand -base64 32)
  warn "Generated new API key - save to 1Password!"
  echo "  API Key: $api_key"
}

get_s3_credentials() {
  if can_use_onepassword; then
    s3_access_key=$(get_onepassword_field "Backup S3 Access Key" --reveal)
    s3_secret_key=$(get_onepassword_field "Backup S3 Secret Key" --reveal)
    s3_bucket=$(get_onepassword_field "Backup S3 Bucket Name")
    s3_endpoint=$(get_onepassword_field "Backup S3 Endpoint")

    if [ -n "$s3_access_key" ] && [ -n "$s3_secret_key" ] && [ -n "$s3_bucket" ]; then
      info "Backup S3 credentials loaded from 1Password"
      return 0
    fi
  fi

  # If any required field is missing, warn but continue (backup is optional)
  warn "Backup S3 credentials not found in 1Password - postgres-backup will not start"
  warn "Add Backup S3 credentials to 1Password to enable automated backups"
  return 1
}

pull_images() {
  log "Pulling Docker images..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
cd ~/docker/link-radar/deploy
docker compose pull
ENDSSH

  log "Images pulled"
}

start_services() {
  log "Starting services..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
cd ~/docker/link-radar/deploy
./bin/up
ENDSSH

  log "Waiting for services to become healthy..."
  sleep 15
}

################################################################################
# Update Mode Functions
################################################################################

update_deployment() {
  log "Starting update to ${deploy_host}..."
  echo ""

  update_code
  pull_images
  restart_services
}

update_code() {
  log "Updating code on server..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
set -e
cd ~/docker/link-radar
git fetch origin
git reset --hard origin/master
echo "Code updated to latest commit"
ENDSSH

  log "Code updated"
}

restart_services() {
  log "Restarting services..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
cd ~/docker/link-radar/deploy
docker compose up -d
ENDSSH

  log "Waiting for services to become healthy..."
  sleep 15
}

################################################################################
# Shared Functions
################################################################################

verify_deployment() {
  log "Verifying deployment..."

  # Check container status
  info "Checking container status..."
  ssh "${deploy_user}@${deploy_host}" bash << 'ENDSSH'
cd ~/docker/link-radar/deploy
docker compose ps
ENDSSH

  # Test health endpoint (from inside container - port not exposed)
  info "Testing health endpoint..."
  if ssh "${deploy_user}@${deploy_host}" "docker exec linkradar-backend curl -f http://localhost:3000/up" &>/dev/null; then
    log "Health check passed!"
  else
    warn "Health check failed - backend may still be starting..."
  fi

  # Test database connection
  info "Testing database connection..."
  if ssh "${deploy_user}@${deploy_host}" "docker exec linkradar-backend bin/rails runner 'Link.count'" &>/dev/null; then
    log "Database connection verified"
  else
    warn "Database check failed - backend may still be starting..."
  fi
}

mark_as_deployed() {
  if [ "$deployed" != "true" ]; then
    # Update local config file
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' 's/DEPLOYED=false/DEPLOYED=true/' "$config_file"
    else
      sed -i 's/DEPLOYED=false/DEPLOYED=true/' "$config_file"
    fi
    log "Marked as deployed in .config/${deploy_env}.env"
    warn "Future deploys will use update mode (faster, preserves config)"
  fi
}

################################################################################
# Script Execution
################################################################################

main "$@"
